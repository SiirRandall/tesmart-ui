package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	"gopkg.in/yaml.v3"
)

type PortMeta struct {
	Name string `yaml:"name"`
	Icon string `yaml:"icon"`
}

type Config struct {
	Ports          map[int]PortMeta `yaml:"ports"`
	PollIntervalMs int              `yaml:"poll_interval_ms"`
	TesmartctlPath string           `yaml:"tesmartctl_path"`
}

var (
	configDir   string
	configFile  string
	configMutex sync.Mutex

	buttons     = map[int]*widget.Button{}
	activePort  = 0
	statusLabel *widget.Label
)

var defaultYAML = `# TeSmart UI (Go/Fyne) config
ports:
  1: { name: "PC 1", icon: "" }
  2: { name: "PC 2", icon: "" }
  3: { name: "PC 3", icon: "" }
  4: { name: "PC 4", icon: "" }
  5: { name: "PC 5", icon: "" }
  6: { name: "PC 6", icon: "" }
  7: { name: "PC 7", icon: "" }
  8: { name: "PC 8", icon: "" }
  9: { name: "PC 9", icon: "" }
  10: { name: "PC 10", icon: "" }
  11: { name: "PC 11", icon: "" }
  12: { name: "PC 12", icon: "" }
  13: { name: "PC 13", icon: "" }
  14: { name: "PC 14", icon: "" }
  15: { name: "PC 15", icon: "" }
  16: { name: "PC 16", icon: "" }
poll_interval_ms: 2000
tesmartctl_path: "tesmartctl"
`

func resolveConfigPaths() (string, string) {
	base, err := os.UserConfigDir()
	if err != nil {
		home, _ := os.UserHomeDir()
		base = filepath.Join(home, ".config")
	}
	dir := filepath.Join(base, "tesmart-ui")
	file := filepath.Join(dir, "config.yaml")
	return dir, file
}

func ensureConfig() error {
	if _, err := os.Stat(configFile); err == nil {
		return nil
	}
	if err := os.MkdirAll(configDir, 0o755); err != nil {
		return err
	}
	return os.WriteFile(configFile, []byte(defaultYAML), 0o644)
}

func loadConfig() (*Config, error) {
	configMutex.Lock()
	defer configMutex.Unlock()

	if err := ensureConfig(); err != nil {
		return nil, err
	}
	data, err := os.ReadFile(configFile)
	if err != nil {
		return nil, err
	}
	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, err
	}
	if cfg.Ports == nil {
		cfg.Ports = map[int]PortMeta{}
	}
	for i := 1; i <= 16; i++ {
		if _, ok := cfg.Ports[i]; !ok {
			cfg.Ports[i] = PortMeta{Name: fmt.Sprintf("Port %d", i)}
		}
	}
	if cfg.PollIntervalMs <= 0 {
		cfg.PollIntervalMs = 2000
	}
	if strings.TrimSpace(cfg.TesmartctlPath) == "" {
		cfg.TesmartctlPath = "tesmartctl"
	}
	return &cfg, nil
}

func saveConfig(cfg *Config) error {
	configMutex.Lock()
	defer configMutex.Unlock()
	out, err := yaml.Marshal(cfg)
	if err != nil {
		return err
	}
	return os.WriteFile(configFile, out, 0o644)
}

func resolveIconPath(p string) string {
	if p == "" {
		return ""
	}
	if filepath.IsAbs(p) {
		return p
	}
	return filepath.Join(configDir, p)
}

func loadIconResource(path string) fyne.Resource {
	if path == "" {
		return nil
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return nil
	}
	return fyne.NewStaticResource(filepath.Base(path), b)
}

var rePort = regexp.MustCompile(`\b([1-9]|1[0-6])\b`)

func parseActivePort(output string) (int, error) {
	matches := rePort.FindAllStringSubmatch(output, -1)
	if len(matches) == 0 {
		return 0, fmt.Errorf("no port number found")
	}
	n, _ := strconv.Atoi(matches[len(matches)-1][1])
	if n < 1 || n > 16 {
		return 0, fmt.Errorf("parsed port out of range")
	}
	return n, nil
}

func runTesmartctl(path string, args ...string) (string, error) {
	cmd := exec.Command(path, args...)
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	err := cmd.Run()
	return buf.String(), err
}

func makeTile(name string, icon fyne.Resource, onTap func()) *widget.Button {
	btn := widget.NewButton(name, onTap)
	btn.Icon = icon
	btn.Alignment = widget.ButtonAlignCenter
	btn.Importance = widget.MediumImportance
	return btn
}

func setActiveHighlight(n int) {
	activePort = n
	for i, b := range buttons {
		if i == n {
			b.Importance = widget.HighImportance
		} else {
			b.Importance = widget.MediumImportance
		}
		b.Refresh()
	}
}

func openConfigFolder() {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", configDir)
	case "windows":
		cmd = exec.Command("explorer", configDir)
	default:
		cmd = exec.Command("xdg-open", configDir)
	}
	_ = cmd.Start()
}

func showAbout(w fyne.Window) {
	dialog.ShowInformation("About",
		"TeSmart 16-Port GUI (Go/Fyne)\n\n• 16 tiles with names & optional icons\n• Polls every 2s\n• Click to switch inputs\n\nConfig: "+configFile,
		w)
}

func showEditDialog(w fyne.Window, cfg *Config) {
	portOptions := make([]string, 16)
	for i := 1; i <= 16; i++ {
		portOptions[i-1] = fmt.Sprintf("%d", i)
	}
	portSelect := widget.NewSelect(portOptions, nil)
	portSelect.SetSelected("1")

	nameEntry := widget.NewEntry()
	nameEntry.SetPlaceHolder("Display name")

	iconPathEntry := widget.NewEntry()
	iconPathEntry.SetPlaceHolder("Icon path (abs or relative to config folder)")

	prefill := func() {
		pn, _ := strconv.Atoi(portSelect.Selected)
		meta := cfg.Ports[pn]
		nameEntry.SetText(meta.Name)
		iconPathEntry.SetText(meta.Icon)
	}
	portSelect.OnChanged = func(string) { prefill() }
	prefill()

	iconPick := widget.NewButtonWithIcon("Choose Icon…", theme.FolderOpenIcon(), func() {
		fd := dialog.NewFileOpen(func(r fyne.URIReadCloser, err error) {
			if err != nil || r == nil {
				return
			}
			iconPathEntry.SetText(r.URI().Path())
			_ = r.Close()
		}, w)
		fd.SetFilter(storageExtFilter([]string{".png", ".jpg", ".jpeg", ".ico", ".icns", ".svg", ".bmp"}))
		fd.Show()
	})

	form := &widget.Form{
		Items: []*widget.FormItem{
			{Text: "Port", Widget: portSelect},
			{Text: "Name", Widget: nameEntry},
			{Text: "Icon", Widget: container.NewBorder(nil, nil, nil, iconPick, iconPathEntry)},
		},
		OnSubmit: func() {
			pn, _ := strconv.Atoi(portSelect.Selected)
			cfg.Ports[pn] = PortMeta{Name: nameEntry.Text, Icon: iconPathEntry.Text}
			_ = saveConfig(cfg)

			// Update UI (we're already on UI thread here)
			btn := buttons[pn]
			btn.SetText(fmt.Sprintf("%s\n(#%d)", nameEntry.Text, pn))
			if res := loadIconResource(resolveIconPath(iconPathEntry.Text)); res != nil {
				btn.SetIcon(res)
			} else {
				btn.SetIcon(theme.ComputerIcon())
			}
			btn.Refresh()
			statusLabel.SetText(fmt.Sprintf("Updated Port %d", pn))
		},
		SubmitText: "Save",
	}
	dialog.NewCustom("Edit Names / Icons", "Close", form, w).Show()
}

// minimal file filter (implements storage.FileFilter)
type extFilter struct{ exts []string }

func storageExtFilter(exts []string) *extFilter { return &extFilter{exts: exts} }
func (f *extFilter) Matches(u fyne.URI) bool {
	low := strings.ToLower(u.Extension())
	for _, e := range f.exts {
		if low == e {
			return true
		}
	}
	return false
}
func (f *extFilter) Name() string { return "Images" }

func main() {
	configDir, configFile = resolveConfigPaths()
	if err := ensureConfig(); err != nil {
		fmt.Println("Failed to create config:", err)
	}

	cfg, err := loadConfig()
	if err != nil {
		fmt.Println("Config error:", err)
		os.Exit(1)
	}

	a := app.New()
	w := a.NewWindow("TeSmart 16-Port HDMI Switch")
	w.Resize(fyne.NewSize(720, 560))

	// Warn if tesmartctl is missing
	if _, err := exec.LookPath(cfg.TesmartctlPath); err != nil {
		dialog.ShowInformation("tesmartctl not found",
			"Couldn't locate '"+cfg.TesmartctlPath+"'.\nSet 'tesmartctl_path' in: "+configFile+
				"\n\nThe app will still run, but switching/polling will fail until this is fixed.",
			w)
	}

	// Grid of tiles using GridWrap to enforce size
	tileSize := fyne.NewSize(150, 110)
	gridWrap := container.New(layout.NewGridWrapLayout(tileSize))

	for i := 1; i <= 16; i++ {
		meta := cfg.Ports[i]
		if meta.Name == "" {
			meta.Name = fmt.Sprintf("Port %d", i)
		}
		iconRes := loadIconResource(resolveIconPath(meta.Icon))
		if iconRes == nil {
			iconRes = theme.ComputerIcon()
		}
		port := i
		btn := makeTile(fmt.Sprintf("%s\n(#%d)", meta.Name, i), iconRes, func() {
			// Optimistic highlight on UI thread
			setActiveHighlight(port)
			// Run switch in background, then marshal UI updates via fyne.Do
			go func(p int) {
				out, err := runTesmartctl(cfg.TesmartctlPath, "input", "set", strconv.Itoa(p))
				if err != nil {
					fyne.Do(func() {
						dialog.ShowError(fmt.Errorf("switch failed: %v\n\n%s", err, out), w)
						statusLabel.SetText("Switch failed")
					})
					return
				}
				fyne.Do(func() {
					statusLabel.SetText(fmt.Sprintf("Switched to input %d", p))
				})
			}(port)
		})
		buttons[i] = btn
		gridWrap.Add(container.NewPadded(btn))
	}

	statusLabel = widget.NewLabel("Ready")
	toolbar := widget.NewToolbar(
		widget.NewToolbarAction(theme.DocumentIcon(), func() { showEditDialog(w, cfg) }),
		widget.NewToolbarAction(theme.FolderOpenIcon(), func() { openConfigFolder() }),
		widget.NewToolbarAction(theme.InfoIcon(), func() { showAbout(w) }),
	)

	content := container.NewBorder(toolbar, statusLabel, nil, nil, gridWrap)
	w.SetContent(content)

	mainMenu := fyne.NewMainMenu(
		fyne.NewMenu("File",
			fyne.NewMenuItem("Edit Names / Icons…", func() { showEditDialog(w, cfg) }),
			fyne.NewMenuItem("Open Config Folder…", func() { openConfigFolder() }),
			fyne.NewMenuItemSeparator(),
			fyne.NewMenuItem("Quit", func() { a.Quit() }),
		),
		fyne.NewMenu("Help",
			fyne.NewMenuItem("About", func() { showAbout(w) }),
		),
	)
	w.SetMainMenu(mainMenu)

	// Poller — runs in background; all UI updates go through fyne.Do
	ticker := time.NewTicker(time.Duration(cfg.PollIntervalMs) * time.Millisecond)
	done := make(chan struct{})

	poll := func() {
		out, err := runTesmartctl(cfg.TesmartctlPath, "input", "get")
		if err != nil {
			fyne.Do(func() { statusLabel.SetText("Polling error: " + err.Error()) })
			return
		}
		port, perr := parseActivePort(out)
		if perr != nil {
			fyne.Do(func() { statusLabel.SetText("Could not parse active input") })
			return
		}
		fyne.Do(func() {
			setActiveHighlight(port)
			statusLabel.SetText(fmt.Sprintf("Active: %d", port))
		})
	}

	go func() {
		poll()
		for {
			select {
			case <-ticker.C:
				poll()
			case <-done:
				return
			}
		}
	}()

	w.SetOnClosed(func() {
		close(done)
		ticker.Stop()
	})

	w.ShowAndRun()
}
